class Game:
    def update_controlled_influence_production_maps(self):
        max_distance = 6
        self.controlled_production_influence_map = np.zeros((max_distance + 1, self.width, self.height))
        self.controlled_production_influence_map[0] = self.production_map * (self.is_enemy_map + self.is_owned_map)
        for distance in range(1, max_distance + 1):
            self.controlled_production_influence_map[distance] = spread_n(self.controlled_production_influence_map[distance - 1], 1)
            self.controlled_production_influence_map[distance] = rebase_map(self.controlled_production_influence_map[distance - 1], False)


    def get_pre_combat_production(self):
        # In the event we are trying to fight in a very high production zone, reroute some attacking power to expand in this area.
        potential_targets_indices = np.transpose(np.nonzero(self.border_map - self.combat_zone_map))
        potential_targets = [self.squares[c[0], c[1]] for c in potential_targets_indices if (1 / self.base_value_map[c[0], c[1]] < self.pre_combat_threshold)]
        if len(potential_targets) == 0:
            return

        potential_targets.sort(key=lambda sq: 1 / self.base_value_map[sq.x, sq.y])

        best_target_value = 1 / self.base_value_map[potential_targets[0].x, potential_targets[0].y]
        # anything with X of the best_value target should be considered. Let's set this to 4 right now.
        while len(potential_targets) > 0 and 1 / self.base_value_map[potential_targets[0].x, potential_targets[0].y] <= (best_target_value + 1):
            target = potential_targets.pop(0)
            self.attack_cell(target, 2)



####################
# Helper Functions #
####################

def rebase_map(map_a, total=True):
    # Takes a map and returns a rebased version where numpy.sum(map) = self.width * self.height
    # If Total = False, rebases to the # of non-zero squares
    if total:
        size = functools.reduce(lambda x, y: x * y, map_a.shape)
    else:
        size = np.sum(map_a != 0)
    factor = size / np.sum(map_a)
    return np.multiply(map_a, factor)
