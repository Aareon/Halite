# ==============================================================================
# Game Class
# ==============================================================================


class Game:


    def update_controlled_influence_production_maps(self):
        max_distance = 6
        self.controlled_production_influence_map = np.zeros((max_distance + 1, self.width, self.height))
        self.controlled_production_influence_map[0] = self.production_map * (self.is_enemy_map + self.is_owned_map)
        for distance in range(1, max_distance + 1):
            self.controlled_production_influence_map[distance] = spread_n(self.controlled_production_influence_map[distance - 1], 1)
            self.controlled_production_influence_map[distance] = rebase_map(self.controlled_production_influence_map[distance - 1], False)

    def get_moves(self):
        # This is the main logic controlling code.
        # Find super high production cells
        self.get_pre_combat_production()
        # 1 - Find combat zone cells and attack them.
#        start = time.time()
        self.get_moves_attack()
#        end = time.time()
#        logging.debug("get_move_attack Frame: " + str(game.frame) + " : " + str(end - start))
        self.get_moves_prepare_strength()
        # 2 - Find production zone cells and attack them
#        start = time.time()
        self.get_moves_production()
#        end = time.time()
#        logging.debug("get production moves Frame: " + str(game.frame) + " : " + str(end - start))
        # 3 - Move all other unassigned cells.
#        start = time.time()
        self.get_moves_other()
#        end = time.time()
#        logging.debug("get other moves Frame: " + str(game.frame) + " : " + str(end - start))

    def get_pre_combat_production(self):
        # In the event we are trying to fight in a very high production zone, reroute some attacking power to expand in this area.
        potential_targets_indices = np.transpose(np.nonzero(self.border_map - self.combat_zone_map))
        potential_targets = [self.squares[c[0], c[1]] for c in potential_targets_indices if (1 / self.base_value_map[c[0], c[1]] < self.pre_combat_threshold)]
        if len(potential_targets) == 0:
            return

        potential_targets.sort(key=lambda sq: 1 / self.base_value_map[sq.x, sq.y])

        best_target_value = 1 / self.base_value_map[potential_targets[0].x, potential_targets[0].y]
        # anything with X of the best_value target should be considered. Let's set this to 4 right now.
        while len(potential_targets) > 0 and 1 / self.base_value_map[potential_targets[0].x, potential_targets[0].y] <= (best_target_value + 1):
            target = potential_targets.pop(0)
            self.attack_cell(target, 2)

    def get_moves_attack(self):
        # Attempts to attack all border cells that are in combat
        potential_targets_indices = np.transpose(np.nonzero(self.combat_zone_map))
        potential_targets = [self.squares[c[0], c[1]] for c in potential_targets_indices]
        # potential_targets.sort(key = lambda x: self.distance_from_enemy[x.x, x.y])
        potential_targets.sort(key=lambda x: self.enemy_strength_map[2, x.x, x.y], reverse=True)

        # TODO: Should sort by amount of overkill damage possible.
        for square in potential_targets:
            self.attack_cell(square, 1)

        self.get_moves_breakthrough()
        # Get a list of all squares within 5 spaces of a combat zone.
        # TODO: This causes bounciness, i should probably do a floodfill of all combat zone squares instead?
        combat_zone_squares = [self.squares[c[0], c[1]] for c in np.transpose(np.nonzero(self.combat_zone_map))]
        combat_distance_matrix = self.friendly_flood_fill_multiple_sources(combat_zone_squares, self.combat_radius)
        # np.savetxt("Masps\maps%i.txt" % self.frame, combat_distance_matrix)
        # combat_distance_matrix[combat_distance_matrix == -1] = 0
        # combat_distance_matrix[combat_distance_matrix == 1] = 0
        combat_squares = [self.squares[c[0], c[1]] for c in np.transpose(np.nonzero(combat_distance_matrix))]
        combat_squares.sort(key=lambda x: x.strength, reverse=True)
        # combat_squares_indices = np.transpose(np.nonzero((self.distance_from_combat_zone <= combat_radius) * (self.move_map == -1)))
        # combat_squares = [self.squares[c[0], c[1]] for c in combat_squares_indices]
        print_map(combat_distance_matrix, "combat_distance_matrix_")

        for square in combat_squares:
            if (square.strength > 0) and (combat_distance_matrix[square.x, square.y] == 1) and (square.move == -1 or square.move == STILL):
                targets = []
                alt_targets = []
                for n in square.neighbors:
                    if n.owner == 0 and n.strength == 0:
                        targets.append(n)
                    elif n.owner == self.my_id:
                        alt_targets.append(n)
                targets.sort(key=lambda x: self.enemy_strength_map[2, x.x, x.y], reverse=True)
                alt_targets.sort(key=lambda x: x.strength)
                success = False
                for t in targets:
                    success = self.move_square_to_target_simple(square, t, False)
                    if success:
                        break
                if not success:
                    for t in targets:
                        success = self.move_square_to_target_simple(square, t, True)
                        if success:
                            break
            elif (square.strength > (square.production * (self.buildup_multiplier[square.x, square.y] + self.distance_from_combat_zone[square.x, square.y]))) and ((square.x + square.y) % 2 == self.frame % 2) and square.move == -1 and square.moving_here == []:
                # self.move_towards_map(square, self.distance_from_combat_zone)
                self.move_towards_map_old(square, combat_distance_matrix)
            # elif square.strength > square.production and square.move == -1 and self.distance_from_combat_zone[square.x, square.y] < 2:
            # elif square.strength >= square.production and square.move == -1 and self.distance_from_combat_zone[square.x, square.y] < 2:

            else:
                if combat_distance_matrix[square.x, square.y] > 1:
                    self.make_move(square, STILL, None)

    def find_nearest_non_owned_border(self, square):

        current_distance = self.distance_from_border[square.x, square.y]
        for n in square.neighbors:
            if self.is_owned_map[n.x, n.y]:
                if self.distance_from_border[n.x, n.y] < current_distance:
                    success = self.move_square_to_target(square, n, True)
                    if success:
                        break

    def move_towards_map(self, square, distance_map):
        current_distance = distance_map[square.x, square.y]
        queue = [square]
        targets = []
        while len(queue) > 0:
            current = queue.pop(0)
            current_distance = distance_map[current.x, current.y]
            for n in current.neighbors:
                if distance_map[n.x, n.y] == 0:
                    targets.append(n)
                elif distance_map[n.x, n.y] < current_distance:
                    queue.append(n)
        random.shuffle(targets)
        target = targets.pop(0)
        # success = self.move_square_to_target(square, target, True)
#        while len(targets) > 0:
#            target = targets.pop(0)
#            success = self.move_square_to_target(square, target, True)
#            if success:
#                return

    def move_towards_map_old(self, square, distance_map, through_friendly=True):
        current_distance = distance_map[square.x, square.y]
        possible_moves = []
        for n in square.neighbors:
            if self.is_owned_map[n.x, n.y]:
                if distance_map[n.x, n.y] <= current_distance - 1:
                    possible_moves.append(n)
        if len(possible_moves) > 0:
            random.shuffle(possible_moves)
            possible_moves.sort(key=lambda sq: self.enemy_strength_map[4, sq.x, sq.y], reverse=True)
            self.move_square_to_target(square, possible_moves[0], True)

    def get_moves_prepare_strength(self):
        # Attempts to build up strength prior to an immediate engagement, only if we aren't already in combat
        # if np.sum(self.combat_zone_map) > 0:
        #     return

        border_prepare_indices = np.transpose(np.nonzero(self.border_map * self.enemy_strength_map[1] > 0))
        enemy_border_squares = [self.squares[c[0], c[1]] for c in border_prepare_indices]

        if len(enemy_border_squares) > 0:
            combat_distance_matrix = self.friendly_flood_fill_multiple_sources(enemy_border_squares, 5)
            combat_distance_matrix[combat_distance_matrix == -1] = 0
            combat_squares = [self.squares[c[0], c[1]] for c in np.transpose(np.nonzero(combat_distance_matrix))]

            for square in combat_squares:
                if (self.distance_from_border[square.x, square.y] > 3) and (square.strength > square.production * self.buildup_multiplier[square.x, square.y] + 5) and ((square.x + square.y) % 2 == self.frame % 2) and square.move == -1 and square.moving_here == []:
                    self.move_towards_map_old(square, combat_distance_matrix)
                elif (square.strength >= 240) and (self.own_strength_map[2, square.x, square.y] >= 750) and (combat_distance_matrix[square.x, square.y] == 1):
                    # Attack
                    targets = []
                    for n in square.neighbors:
                        if combat_distance_matrix[n.x, n.y] == 0:
                            targets.append(n)
                    targets.sort(key=lambda n: self.enemy_strength_map[1, n.x, n.y], reverse=True)
                    self.move_square_to_target_simple(square, targets[0], False)
                elif square.move == -1:
                    self.make_move(square, STILL, None)

    def get_moves_production(self):
        # Tries to find the best cells to attack from a production standpoint.
        # Does not try to attack cells that are in combat zones.
        # potential_targets_indices = np.transpose(np.nonzero((self.border_map - self.combat_zone_map) * (self.enemy_strength_map[1] == 0)))
        potential_targets_indices = np.transpose(np.nonzero((self.value_production_map != 9999)))
        potential_targets = [(self.squares[c[0], c[1]], self.value_production_map[c[0], c[1]], 1) for c in potential_targets_indices]

        potential_targets = []
        for c in potential_targets_indices:
            target = self.squares[c[0], c[1]]
            value = self.value_production_map[c[0], c[1]]
            cells_out = 1
            while cells_out <= self.production_cells_out:
                potential_targets.append((target, value, cells_out))
                cells_out += 1

        if len(potential_targets) == 0:
            return
        potential_targets.sort(key=lambda x: x[0].strength)
        potential_targets.sort(key=lambda x: x[1] + (x[2] * 1))

        # Keep only the top 80ile?
        # potential_targets = potential_targets[0:int(len(potential_targets) * .9)]
        remove_targets = potential_targets[int(len(potential_targets) * 0.85):]
        for t in remove_targets:
            potential_targets.remove(t)
            self.value_production_map[t[0].x, t[0].y] = 9999

        # best_target_value = potential_targets[0][1]
        # anything with X of the best_value target should be considered. Let's set this to 4 right now.
        while len(potential_targets) > 0:  # and potential_targets[0][1] <= (best_target_value + 4000):
            target = potential_targets.pop(0)
            success = self.attack_cell(target[0], target[2], target[2])
            if success and target[2] < self.production_cells_out:
                potential_targets = list(filter(lambda sq: sq[0] != target[0], potential_targets))

    def get_moves_breakthrough(self):
        # Determine if we should bust through and try to open up additional lanes of attack into enemy territory
        # Best to have a separate lane. so we should evaluate squares that are not next to already open channels.
        # We are only looking at squares which are next to the enemy already.
        potential_squares_indices = np.transpose(np.nonzero((self.border_map - self.combat_zone_map) * (self.enemy_strength_map[1] > 0)))
        potential_squares = [self.squares[c[0], c[1]] for c in potential_squares_indices]
        # We only want to bust through if we have a lot of strength here.
        # logging.debug(str(self.own_strength_map[4]))
        for square in potential_squares:
            if self.own_strength_map[4, square.x, square.y] > 750 and (self.own_strength_map[4, square.x, square.y] > 1.5 * self.enemy_strength_map[4, square.x, square.y]):
                self.attack_cell(square, 1)

    def get_moves_other(self):
        # Tries to move to
        idle_squares_indices = np.transpose(np.nonzero((self.move_map == -1) * self.is_owned_map))
        idle_squares = [self.squares[c[0], c[1]] for c in idle_squares_indices]

        if len(idle_squares) == 0:
            return

        # Move squares closer to the border first.
        idle_squares.sort(key=lambda sq: self.distance_from_border[sq.x, sq.y])

        for square in idle_squares:
            if square.strength > square.production * self.buildup_multiplier[square.x, square.y] and square.move == -1 and square.moving_here == []:
                if self.percent_owned > 0.65:
                    self.find_nearest_non_owned_border(square)
                    # self.move_towards_map(square, self.distance_from_border)
                else:
                    # Move towards the closest border
                    # if not self.inner_border_map[square.x, square.y]:
                        # For now, move to the square with the lowest recovery
                    value_map = (self.value_production_map + self.distance_map_no_decay[square.x, square.y] * 1) * self.border_map
                    # best_target_value = (self.recover_wtd_map * (self.border_map - self.combat_zone_map)).argmin()
                    # value_map = value_map * (1 - self.combat_zone_map)
                    value_map[np.nonzero(self.combat_zone_map)] = 0
                    value_map += self.distance_map_no_decay[square.x, square.y] * 0.66 * self.combat_zone_map
                    value_map -= self.controlled_production_influence_map[5, square.x, square.y] * 5 * self.combat_zone_map
                    # value_map[self.combat_zone_map == 1] = self.distance_map_no_decay[square.x, square.y] * .8
                    value_map[value_map == 0] = 9999
                    # tx, ty = np.unravel_index(value_map.argmin(), (self.width, self.height))
                    tx, ty = np.unravel_index(value_map.argmin(), (self.width, self.height))
                    target = self.squares[tx, ty]
                    # We're targeting either a combat square, or a production square. Don't move towards close production squares.
                    if self.distance_between(square, target) < 6 and self.distance_from_combat_zone[square.x, square.y] < 7:
                        if (square.x + square.y) % 2 != game.frame % 2:
                            continue

                    if (self.enemy_strength_map[3, square.x, square.y] > 0) and (((square.x + square.y) % 2) != (game.frame % 2)):
                        self.make_move(square, STILL, None)
                    elif self.combat_zone_map[tx, ty]:
                        if self.distance_between(square, target) > 14:
                            self.move_square_to_target_simple(square, target, True)
                        elif self.distance_between(square, target) > 1:
                            self.move_square_to_target(square, target, True)
                    else:
                        if self.distance_between(square, target) > 14:
                            self.move_square_to_target_simple(square, target, True)
                        elif self.distance_between(square, target) > self.production_cells_out - 1:
                            self.move_square_to_target(square, target, True)


####################
# Helper Functions #
####################

def rebase_map(map_a, total=True):
    # Takes a map and returns a rebased version where numpy.sum(map) = self.width * self.height
    # If Total = False, rebases to the # of non-zero squares
    if total:
        size = functools.reduce(lambda x, y: x * y, map_a.shape)
    else:
        size = np.sum(map_a != 0)
    factor = size / np.sum(map_a)
    return np.multiply(map_a, factor)

